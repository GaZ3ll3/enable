<h1>Chaco's Free Type engine</h1>
<h4>by Eric Jones <a href="mailto:eric@enthought.com">eric@enthought.com</a></h4>

This document covers the simple FreeType2 font rendering interface included 
in Chaco.

<h2>Downloads:</h2>
    <blockquote>
    source package: <a href="freetype-0.1.0.tar.gz">freetype-0.1.0.tar.gz </a><br>
    windows binaries (Python 2.2.1): <a href="freetype-0.1.0.win32-py2.2.exe">freetype-0.1.0.win32-py2.2.exe </a> 
    </blockquote>

<h2>Document Contents</h2>
<a href="#Introduction">Introduction</a><br>
<a href="#Availability and Installation">Installation</a><br>
<a href="#Standard_Usage">Standard Usage</a><br>
<a href="#Increasing_Font_Rendering_Resolution">Increasing Font Rendering Resolution</a><br>
<a href="#Rendering_aliased_text">Rendering aliased text</a><br>
<a href="#Selecting_different_fonts">Selecting different fonts</a><br>
<a href="#More_on_selecting_fonts_and_encodings">More on selecting fonts and encodings</a><br>
<a href="#Accessing_the_current_font_object">Accessing the current font object</a><br>
<a href="#Rotating_and_transforming_text">Rotating_and_transforming_text</a><br>
<a href="#Rendering_unicode_strings">Rendering unicode strings</a><br>
<a href="#Existing_Issues">Existing Issues </a>
<p>
<a name="#Introduction"></a>
<h2>Introduction</h2>
Chaco includes a simple Python interface to <a href="http://www.freetype.org">
FreeType 2 </a> that draws text into an image (Numeric array).  From there, the 
text image can be transferred to the screen on a number of GUI backends 
(wxPython, OpenGL, etc.).  Freetype is an open source font rendering engine that 
handles multiple font formats (truetype, opentype, type1, and others) and 
renders both aliased (i.e. standard monotone text) as well as anti-aliased text. 
Freetype it praised as a high quality text, and is the de- facto standard 
rendering engine on Linux systems (its used in KDE and elsewhere).  It also can
draw arbitrarily transformed text which is why we want to use it instead of 
standard system calls (which often only handle rotated text) for Chaco.
<p>
Robert Kern has written a more complete Python interface to Freetype 1 called <a 
href="http://starship.python.net/crew/kernr/Projects.html">PyFT</a>. Robert and 
I discussed updating PyFT to Freetype 2 and fixing some issues with memory 
management, etc.  Together, we decided that a less ambitious interface that 
served the needs of Chaco was a better solution.  The result is a small package
(about 250 lines for the interface and 800 lines of py/C in the weave wrapper)
for querying the available fonts on a system and rendering arbitrarily 
transformed text (both ascii and unicode) into a Numeric array.  The rendering 
mode can be set to aliased or anti-aliased.
<p>
The <code>freetype</code> wrapper is considered alpha.  I have integrated it 
into the wxPython backend of Chaco, and it does work.  But the test are fairly 
limited.  Still, since the interface is small, the major issues (if any) should 
be found quickly.

<a name="#Availability_and_Installation"></a>
<h2>Availability and Installation</h2>

The <code>freetype</code> package is part of Chaco.  Chaco is currently only 
accessible through CVS.  However, I've also bundled freetype up so that people
can try it out separately.  When Chaco is released, the freetype package 
will install as its own package (not nested within Chaco) so code using this
version will continue to work with the final distribution (barring interface 
changes).
<p>
    <blockquote>
    <h3>Downloads:</h3>
    source package: <a href="freetype/freetype-0.1.0.tar.gz">freetype-0.1.0.tar.gz </a><br>
    windows binaries (Python 2.2.1): <a href="freetype/freetype-0.1.0.win32-py2.2.exe">freetype-0.1.0.win32-py2.2.exe </a> 
    </blockquote>
<p>
The source package contains a <code>setup.py</code> file, and only depends on 
Numeric for standard usage.  The dependencies on weave have been removed in the 
distribution to simplify builds.  If a recent CVS version of <code>scipy.weave</code> 
is present, the <code>_ft.cpp</code> will be rebuilt.  

Also, if you want to use the <code>view()</code> method for <code>Glyphs</code>
objects (see the samples below), you'll also need wxPython and SciPy. 

If you want to build from the CVS, you'll need the CVS version of 
<code>scipy.weave</code>.  It has support for unicode objects that older 
versions don't have.

To build from source, do the following (on Unix):

    <blockquote><pre>
    > tar -xzvf freetype-0.1.0.tar.gz
    > cd freetype-0.1.0
    > python setup.py build
    > python setup.py install    
    </pre></blockquote>

On windows, you can build from source using either the mingw32 compiler or
MSVC++.  Pretty much the same instructions apply, except you may want to use
winzip for the unpacking process if you don't have tar installed on your 
machine.  The easiest approach on windows is to use the binaries supplied 
above.
<p>    
<a name="#Standard_Usage"></a>
<h2>Standard Usage</h2>
Interaction with the freetype engine generally occurs through the 
<code>FreeType</code> class.

    <blockquote><pre>
    # only needed if you'd like to view the rendered text in a plot window
    >>> import gui_thread
    <wxPython imported>
    >>> from scipy import plt
    
    >>> import freetype
    >>> ft = freetype.FreeType()
    >>> rendered_text = ft.render("please")
    >>> rendered_text.view()
    </pre></blockquote>
<p>
<center><img src="img0001.png"></center>
<p>
The <code>rendered_text</code> object is a <code>Glyphs</code> instance that 
holds the image array for the rendered text as well as some other information 
about the size of the image, etc.  The image is stored as an unsigned character 
array (type UnsignedInt8) of gray scale values.
<p>
The results here don't look so good because some of the characters run together, 
and the resolution is somewhat low.  Increasing the rendering resolution can 
improve the results (<em>although I thought this should be better than it 
is.</em>)
<p>
<a name="#Increasing_Font_Rendering_Resolution"></a>
<h2>Increasing Font Rendering Resolution</h2>

The FreeType initializer  has a <code>dpi</code> keyword argument that set the 
"dots per inch" of the display device you want to render for.  This affects the 
size and resolution of fonts for a given point size (10, 12, etc.).  72 dpi is 
the standard and default.  I've noticed though, that this gives pretty lousy 
font rendering for font sizes below 14 points.  I use 133.3 on my laptop because 
it has a high resolution screen, and this looks fairly good with the text 
rendered at the correct size.  However, on low resolution screens the letters 
will appear too large.

    <blockquote><pre>
    >>> ft = freetype.FreeType(dpi=133.3)
    >>> rendered_text = ft.render("please")
    >>> rendered_text.view()
    </pre></blockquote>
<p>
<center><img src="img0002.png"></center>
<p>
<em>Note: I'd really like a to know how to query the system for its dpi value.
If you know how to do this on a particular system, please email me.  </em>

<a name="#Rendering_aliased_text"></a>
<h2> Rendering aliased text. </h2>

By default, <code>FreeType</code> renders antialiased text.  The 
<code>antialias()</code> method will disable this if desired.

    <blockquote><pre>
    >>> ft = freetype.FreeType(dpi=133.3)
    >>> rendered_text = ft.antialias(0)
    >>> rendered_text = ft.render("please")
    >>> rendered_text.view()
    </pre></blockquote>
<p>
<center><img src="img0003.png"></center>
<p>
<a name="#Selecting_different_fonts"></a>
<h2> Selecting different fonts </h2>
<p>
FreeType can handle a lot of different font formats, but we currently only 
support scalable fonts (this limitation will probably continue) and have only 
tested with TrueType on Windows.  <code>freetype</code> reads the available 
fonts from a user specified directory (<em>I'd like this to be 
automatically found</em>) and keeps track of the available fonts.  This is
managed by a <code>FontLookup</code> class, but most of the information 
is also exposed through the <code>FreeType</code> class. 
<p>

    <blockquote><pre>
    >>> ft = freetype.FreeType(dpi=133.3)
    >>> ft.available_fonts()
    ['arial', 'arial black', 'arial narrow', 'arial unicode ms', 'batang', 
    'book ant iqua', 'bookman old style', 'century', 'century gothic', 
    'comic sans ms', 'courier new', 'estrangelo edessa', 
    'franklin gothic medium', 'garamond', 'gautami', 'georgia', 
    'haettenschweiler', 'impact', 'latha', 'lucida console', 
    'lucida sans unicode', 'mangal', 'marlett', 'microsoft sans serif', 
    'monotype corsiva', 'ms mincho', 'ms outlook', 'mv boli', 
    'opensymbol', 'palatino linotype', 'pmingliu', 'raavi', 'shruti', 
    'simsun', 'sylfaen', 'symbol', 'tahoma', 'times new roman', '
    trebuchet ms', 'tunga', 'verdana', 'webdings', 'wingdings', 
    'wingdings 2', 'wingdings 3']    
    >>> ft.select_font("times new roman",size=24)
    >>> rendered_text = ft.render("please")
    >>> rendered_text.view()
    </pre></blockquote>
<p>
<center><img src="img0004.png"></center>
<p>
<blockquote><em>
Note: Font management is one of the areas I'd like to see some improvement.  We 
need some simple name matching to handle "times" instead of "times new roman", 
etc.  Also, I have no idea where the font files are stored on Unix systems or 
even if there is a common location for these guys.  It would be very good to 
auto detect the location of font files instead of having a hard coded path.  On 
windows systems, it'll probably be pretty easy because there are only about 3 
places to look (I think).  On Unix, it could be a lot more difficult.
<p>
Another thought is to also include 4 or 5 standard fonts with the <code> 
freetype</code> package so that there are always several available fonts. I'm 
not entirely happy without how the Microsoft fonts are rendering, so there might 
be some aesthetic benefits also if there are some "freetype optimized" fonts out 
there that are open sourced.
</em></blockquote>
<p>
<a name="#More_on_selecting_fonts_and_encodings"></a>
<h2> More on selecting fonts and encodings</h2>
The <code>select_font()</code> method has the following full definition:

    <blockquote><code>
    def select_font(self,name, size=12, style='regular', encoding=None)
    </code></blockquote>

The <code>size</code> keyword specifies the size of the font in points.  Note 
that the actual size of the font also relies on the font itself and the 
<code>dpi</code> setting used to initialize the <code>FreeType</code> object. 
<code>style</code> is one of 4 strings: <code> 'regular'</code>, 
<code>'bold'</code>, <code>'italic'</code>, or <code>'bold italic'</code>. 
Currently, <code>bold</code> and <code>italic</code> settings are only available 
for fonts that have a specialized font to handle the styles. Adding a style 
transformation matrix to turn fonts that only have a <code>regular</code> style 
font into styled fonts shouldn't be hard, but hasn't been attempted yet. <em> 
Note: Does anyone have a set of transformation matrices that does a good job of 
creating each of these styles?</em>
<p>
The <code>encoding</code> string specifies the character map that maps characters
to the glyph that displays them.  By default, unicode (<code>'unic'</code>) 
is used for all the fonts that support that style.  If unicode is supported, then
symbol (<code>'symb'</code>) is attempted.  Another common style is Apple 
Roman(<code>'armn'</code>).  You can ask a font object what encodings it supports:

    <blockquote><pre>
    >>> ft = freetype.FreeType(dpi=133.3)
    >>> ft.select_font("times new roman",size=24)
    >>> the_font.supported_encodings()
    ['unic', 'armn', 'unic']
    </pre></blockquote>

<em>Note: I'm not sure why 'unic' is listed twice. </em>
<p>
If you try to set the encoding to an unsupported value, it'll raise a ValueError.
Here is the list of potentially supported encodings:
    <center>
    <table>
    <tr><td>symbol</td>         <td><code>"symb"</code></td></tr>
    <tr><td>unicode</td>        <td><code>"unic"</code></td></tr>
    <tr><td>latin1</td>         <td><code>"lat1"</code></td></tr>
    <tr><td>latin2</td>         <td><code>"lat2"</code></td></tr>
    <tr><td>SJIS</td>           <td><code>"sjis"</code></td></tr>
    <tr><td>gb2312</td>         <td><code>"gb"</code></td></tr>
    <tr><td>big5</td>           <td><code>"big5"</code></td></tr>
    <tr><td>wansung</td>        <td><code>"wans"</code></td></tr>
    <tr><td>johab</td>          <td><code>"joha"</code></td></tr>
    <tr><td>adobe standard</td> <td><code>"ADOB"</code></td></tr>
    <tr><td>adobe expert</td>   <td><code>"ADBE"</code></td></tr>
    <tr><td>adobe custom</td>   <td><code>"ADBC"</code></td></tr>
    <tr><td>apple roman</td>    <td><code>"armn"</code></td></tr>
    </table> 
    </center>
<p>
I haven't used encodings much yet, so I don't have any practical examples to 
share. So far, accepting the default encoding has worked well.
<p>
<em> Note: I haven't experimented with how the various encodings interact 
with the fact that all strings passed into the freetype renderer are unicode.  I 
don't think it is an issue, but it might have some affect. </em>

<a name="Accessing_the_current_font_object"></a>
<h2> Accessing the current font object</h2>
The current font object is accessible through the <code>font()</code> method. 
It allows you to set and retrieve the font of a FreeType object.  It will only 
allow font objects created by the same <code>FreeType</code> object to be 
assigned to the object.  If <code>font</code> is called without an argument, it 
returns a reference to the current font object.

The <code>Font</code> class has the following methods:

    <blockquote><pre>
    class Font:
        def name(self):
        def style(self):
        def supported_encodings(self):
        def glyph_count(self):
        def size(self,sz=None):
        def encoding(self,encoding=None):
        def char_index_from_int(self,value):
    </pre></blockquote>

For more info, you'll have to look at the source.
    
<a name="Rotating_and_transforming_text"></a>
<h2> Rotating and transforming text </h2>
<p>
The <code>transform()</code> method sets a 4 element transformation
matrix used during rendering.  The [a,b,c,d] elements are positioned as
follows:
<p>
    <blockquote><pre>
    |a b|
    |c d|
    </pre></blockquote>
<p>
<code>transform()</code> also returns the current transform for the 
<code>FreeType</code> object.  You can call it without any arguments if
you just want to query for the transform value.
<p>
Here is an example where the text is rotated 45 degrees using the affine
matrix tools in Chaco.

    <blockquote><pre>
    >>> from scipy import *
    >>> import affine
    >>> m = affine.affine_identity()
    >>> m = affine.rotate(m,pi/4)
    >>> a,b,c,d,tx,ty = affine.affine_params(m)
    
    >>> ft = freetype.FreeType(dpi=133.3)
    >>> ft.transform([a,b,c,d])
    array([ 0.70710678,  0.70710678, -0.70710678,  0.70710678])
    >>> ft.select_font("times new roman",size=24)
    >>> rendered_text = ft.render("please")
    >>> rendered_text.view()
    </pre></blockquote>
<p>
<center><img src="img0005.png"></center>
<p>
<a name="#Rendering_unicode_strings"></a>
<h2> Rendering unicode strings </h2>
All strings are actually converted to unicode before being sent
to the freetype rendering engine.  For fonts that support unicode
characters, you can render until your hearts content.  Here is one
that scientist are interested in:

    <blockquote><pre>
    >>> ft = freetype.FreeType(dpi=133.3)
    >>> ft.select_font("arial unicode ms",size=24)
    >>> rendered_text = ft.render(u'Angstrom \xc5')
    >>> rendered_text.view()
    </pre></blockquote>
<p>
<center><img src="img0008.png"></center>
<p>    
And here is a kanji string:
<p>
    <blockquote><pre>
    >>> ft = freetype.FreeType(dpi=133.3)
    >>> ft.select_font("arial unicode ms",size=24)
    >>> rendered_text = ft.render(u'\u4ee0\u4ee1\u4ee2\u4ee3\u4ee4')
    >>> rendered_text.view()
    </pre></blockquote>
<p>
<center><img src="img0006.png"></center>
<p>    
<em> Note: Someone with a more intelligent kanji string, please send
it to me.  I just picked 4 sequential characters at random from the
unicode table.
</em>

<a name="Existing_Issues"></a>
<h2> Existing Issues </h2>
These are generally requests for help on issues that I've run into.  If you
have knowledge about these, please email the 
<a href="mailto:scipy-dev@scipy.org">scipy-dev</a> list and we can have a 
discussion there about it. Thanks.

<h3>Font rendering quality</h3>
I haven't been as happy with the output of FreeType as I expected to be. At 72 
dpi and 12 point fonts, the letters in the fonts run together.  At higher 
resolutions, the aliased rendering seems jagged compared to letting the system 
render the text.  Most people have sung high praises for FreeType's output, so 
I'm betting that I don't have something set up correctly, or I should use 
different fonts.  My only tests have come with the standard Microsoft TrueType 
fonts.  

I am using kerning, but have noticed that most character pairs don't
have kerning information for the fonts I've tried.  The "AV" character pair
is a notable exception.

Antialiased fonts generally look fine at higher resolutions.  Chaco doesn't
support alpha blending yet, though, so there isn't any way to display them
on a background at the moment.

<h3>System font management</h3>
On windows, finding the system fonts isn't going to be that hard.  On Unix,
it may also be easy, but I don't know.  Also, currently I've only tested 
TrueType fonts.  Type1, etc. may (should) work also.  I do know that 
non-scalable fonts will not work.  

The font system management needs a little work so that it is easier to 
choose some default fonts like "times" and others.  It should have a simple 
mapping between several standard names and the closest font available that
has that style.

I've also thought that carrying a few fonts around within FreeType might
be a good idea.  If anyone has knowledge of a set of fonts that work well
with FreeType and have a BSD compatible license, please let me know.

<h3>Speed</h3>
The <code>create_glyph_list</code> method doesn't do any caching at all.  
In simple tests, it looked like creating this list took the same amount
of time as rendering the glyphs.  FreeType has a caching API that might
cut this time down to imperceptible.  I doubt adding support for it is
that hard, but it isn't a high priority of mine.  I'd be happy if someone
that knew the caching API took up the cause though.
<p>
Rendering glyphs also takes a noticeable amount of time.  Building freetype
with optimization flags sped it up by 33%, but it is still quite a bit more
expensive than having the system draw the fonts.  I don't know if this will
be noticeable in the end.
<p>
The conversion from an array into a wxPython bitmap turned out to be a 
real mess and is probably really slow.  A weave method -- and probably a
bug fix to wxPython's bitmap masks rendering-- will improve this markedly.
<p>
The bug I'm talking about in the wxPython masks appears because Chaco
flips the direction of positive y in the device context.  As a result,
bitmaps are rendered upside down.  However, the mask is not!  It is 
rendered right side up.  I don't know if this is a wxPython issue or
is a problem in the underlying windows API.  Anyway, the current fix is
to set the mask separately to the correct orientation which is time 
consuming.  This will also come up in image rendering.

<h3>Antialiased text</h3>
We have to have alpha blending capabilities in Chaco before this becomes a 
reality.  Alpha blending isn't that hard to write, but it may be slow.  
The Windows API has an <code>AlphaBlend</code> method which we can weavify
for use in wxPython.  If GTK has a similar API method, then wxPython can 
be made to work with alpha blending.  OpenGL I'm sure can do it pretty 
easily. TkInter... I don't know.

Anyway, alpha blending isn't the highest priority, so for now I'm sticking
with aliased rendering.

